# WebAssembly Deployment & Compatibility Guide

## 🌐 Browser Compatibility

### Core WebAssembly Support (2024-2025)

**Universally Supported (99%+ browsers):**
- ✅ Chrome/Edge 57+ (March 2017)
- ✅ Firefox 52+ (March 2017)
- ✅ Safari 11+ (September 2017)
- ✅ Opera 44+ (March 2017)
- ✅ Samsung Internet 7.2+
- ✅ iOS Safari 11+
- ✅ Android Chrome 57+

**Key Statistic:** WebAssembly has near-universal support in modern browsers with 97%+ global coverage.

---

### Advanced WebAssembly Features

#### **1. Threading (SharedArrayBuffer + Atomics)**
**Status:** Requires secure context (HTTPS + specific headers)

**Browser Support:**
- ✅ Chrome 74+ (with headers)
- ✅ Firefox 79+ (with headers)
- ✅ Safari 15.2+ (with headers)
- ✅ Edge 79+

**Required Headers:**
```
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
```

---

#### **2. SIMD (Single Instruction Multiple Data)**
**Status:** Stable in all major browsers (2024)

**Browser Support:**
- ✅ Chrome 91+ (June 2021)
- ✅ Firefox 89+ (June 2021)
- ✅ Safari 16.4+ (March 2023)
- ✅ Edge 91+

**Performance Gain:** 2-4x speedup for vector operations

---

#### **3. Exception Handling**
**Status:** Stable (2024)

**Browser Support:**
- ✅ Chrome 95+
- ✅ Firefox 100+
- ✅ Safari 15.2+
- ✅ Edge 95+

---

#### **4. Garbage Collection (GC)**
**Status:** Available in Safari, in development for Chrome/Firefox

**Browser Support:**
- ✅ Safari 16.4+ (March 2023)
- 🚧 Chrome (behind flag)
- 🚧 Firefox (in development)

---

#### **5. Tail Call Optimization**
**Status:** Recently stabilized

**Browser Support:**
- ✅ Safari 18+ (September 2024)
- 🚧 Chrome (in development)
- 🚧 Firefox (in development)

---

### Feature Detection

```javascript
// Check if WebAssembly is supported
function supportsWebAssembly() {
  try {
    if (typeof WebAssembly === 'object' &&
        typeof WebAssembly.instantiate === 'function') {
      const module = new WebAssembly.Module(
        Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00)
      );
      if (module instanceof WebAssembly.Module) {
        return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
      }
    }
  } catch (e) {
    return false;
  }
  return false;
}

// Check for SIMD support
async function supportsSIMD() {
  try {
    const simdTest = await WebAssembly.validate(
      new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11])
    );
    return simdTest;
  } catch (e) {
    return false;
  }
}

// Check for threading support
function supportsThreads() {
  return typeof SharedArrayBuffer !== 'undefined' && 
         typeof Atomics !== 'undefined';
}

// Check for bulk memory operations
async function supportsBulkMemory() {
  const bulkMemoryTest = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,
    0x05, 0x03, 0x01, 0x00, 0x01,
    0x0b, 0x07, 0x01, 0x00, 0x41, 0x00, 0x41, 0x00, 0xfc, 0x08, 0x00, 0x00
  ]);
  return await WebAssembly.validate(bulkMemoryTest);
}

// Usage
(async () => {
  console.log('WebAssembly:', supportsWebAssembly());
  console.log('SIMD:', await supportsSIMD());
  console.log('Threads:', supportsThreads());
  console.log('Bulk Memory:', await supportsBulkMemory());
})();
```

---

## 🚀 Deployment Strategies

### **1. Vercel Deployment**

#### **vercel.json**
```json
{
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "Cross-Origin-Opener-Policy",
          "value": "same-origin"
        },
        {
          "key": "Cross-Origin-Embedder-Policy",
          "value": "require-corp"
        }
      ]
    },
    {
      "source": "/(.*)\\.(wasm)$",
      "headers": [
        {
          "key": "Content-Type",
          "value": "application/wasm"
        },
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        }
      ]
    }
  ],
  "rewrites": [
    {
      "source": "/(.*)",
      "destination": "/index.html"
    }
  ]
}
```

#### **Build Configuration**
```json
{
  "buildCommand": "npm run build",
  "outputDirectory": "dist",
  "installCommand": "npm install && wasm-pack build --target web"
}
```

---

### **2. Netlify Deployment**

#### **netlify.toml**
```toml
[build]
  command = "npm run build"
  publish = "dist"

[[headers]]
  for = "/*"
  [headers.values]
    Cross-Origin-Opener-Policy = "same-origin"
    Cross-Origin-Embedder-Policy = "require-corp"

[[headers]]
  for = "/*.wasm"
  [headers.values]
    Content-Type = "application/wasm"
    Cache-Control = "public, max-age=31536000, immutable"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
```

---

### **3. AWS S3 + CloudFront**

#### **S3 Bucket Configuration**
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "PublicReadGetObject",
      "Effect": "Allow",
      "Principal": "*",
      "Action": "s3:GetObject",
      "Resource": "arn:aws:s3:::your-bucket/*"
    }
  ]
}
```

#### **CloudFront Custom Headers (Lambda@Edge)**
```javascript
exports.handler = async (event) => {
  const response = event.Records[0].cf.response;
  const headers = response.headers;

  // Add COOP and COEP headers
  headers['cross-origin-opener-policy'] = [{
    key: 'Cross-Origin-Opener-Policy',
    value: 'same-origin'
  }];
  headers['cross-origin-embedder-policy'] = [{
    key: 'Cross-Origin-Embedder-Policy',
    value: 'require-corp'
  }];

  // Set correct MIME type for .wasm files
  const request = event.Records[0].cf.request;
  if (request.uri.endsWith('.wasm')) {
    headers['content-type'] = [{
      key: 'Content-Type',
      value: 'application/wasm'
    }];
  }

  return response;
};
```

---

### **4. Docker + Node.js Server**

#### **Dockerfile**
```dockerfile
FROM node:18-alpine

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy application files
COPY . .

# Build Wasm modules
RUN npm run build:wasm

# Expose port
EXPOSE 3000

CMD ["node", "server.js"]
```

#### **server.js (Express)**
```javascript
const express = require('express');
const path = require('path');
const app = express();

// Serve static files
app.use(express.static('public', {
  setHeaders: (res, filePath) => {
    // Set MIME type for .wasm files
    if (filePath.endsWith('.wasm')) {
      res.setHeader('Content-Type', 'application/wasm');
      res.setHeader('Cache-Control', 'public, max-age=31536000, immutable');
    }
    
    // Add COOP and COEP headers for all responses
    res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');
    res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');
  }
}));

// Serve index.html for all routes (SPA)
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

---

### **5. Nginx Configuration**

#### **/etc/nginx/nginx.conf**
```nginx
server {
    listen 80;
    server_name your-domain.com;

    root /var/www/html;
    index index.html;

    # Add security headers
    add_header Cross-Origin-Opener-Policy "same-origin" always;
    add_header Cross-Origin-Embedder-Policy "require-corp" always;

    # Serve .wasm files with correct MIME type
    location ~* \.wasm$ {
        types { application/wasm wasm; }
        add_header Cache-Control "public, max-age=31536000, immutable";
        add_header Cross-Origin-Opener-Policy "same-origin" always;
        add_header Cross-Origin-Embedder-Policy "require-corp" always;
        
        # Enable compression
        gzip on;
        gzip_types application/wasm;
        gzip_min_length 1000;
    }

    # Enable Brotli compression (if module installed)
    location ~* \.wasm$ {
        brotli on;
        brotli_types application/wasm;
        brotli_comp_level 6;
    }

    # SPA routing
    location / {
        try_files $uri $uri/ /index.html;
    }
}
```

---

## 📦 Build & Bundle Optimization

### **1. Minimize Wasm File Size**

```bash
# Install wasm-opt (from Binaryen toolkit)
npm install -g binaryen

# Optimize Wasm file
wasm-opt -O3 --enable-simd input.wasm -o output.wasm

# Further optimization with aggressive flags
wasm-opt -O4 --enable-simd --enable-bulk-memory input.wasm -o output.wasm

# Strip debug information
wasm-strip input.wasm
```

**Size Comparison:**
- Debug build: 500 KB
- Release build (-O3): 150 KB
- Optimized (-O4): 120 KB
- Stripped: 100 KB
- Compressed (Brotli): 30 KB

---

### **2. Code Splitting**

```javascript
// Lazy load Wasm modules
const loadImageProcessor = () => import('./image-processor.wasm');
const loadDataAnalyzer = () => import('./data-analyzer.wasm');

// Load on demand
async function processImage(image) {
  const module = await loadImageProcessor();
  return module.process(image);
}
```

---

### **3. Compression**

```javascript
// Server-side (Express)
const compression = require('compression');

app.use(compression({
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    // Compress .wasm files
    return compression.filter(req, res) || req.url.endsWith('.wasm');
  },
  level: 9
}));
```

**Compression Ratios:**
- Gzip: 70-80% reduction
- Brotli: 75-85% reduction

---

### **4. CDN Deployment**

```javascript
// Vite config for CDN
export default defineConfig({
  base: 'https://cdn.example.com/',
  build: {
    rollupOptions: {
      output: {
        assetFileNames: (assetInfo) => {
          if (assetInfo.name.endsWith('.wasm')) {
            return 'wasm/[name]-[hash][extname]';
          }
          return 'assets/[name]-[hash][extname]';
        }
      }
    }
  }
});
```

---

## 🔒 Security Considerations

### **1. Content Security Policy (CSP)**

```html
<meta http-equiv="Content-Security-Policy" 
      content="
        default-src 'self';
        script-src 'self' 'wasm-unsafe-eval';
        worker-src 'self' blob:;
        child-src 'self' blob:;
      ">
```

**Note:** `wasm-unsafe-eval` is required for `WebAssembly.instantiate()`.

---

### **2. Subresource Integrity (SRI)**

```html
<!-- For CDN-hosted Wasm files -->
<script type="module">
  import init from './module.js';
  
  const response = await fetch('./module.wasm', {
    integrity: 'sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC'
  });
  
  await init(response);
</script>
```

---

### **3. Sandboxing**

WebAssembly runs in a sandboxed environment:
- ✅ Memory isolation
- ✅ No direct system access
- ✅ Limited to imported functions
- ✅ Can't access DOM directly

**Additional Security:**
```javascript
// Limit memory growth
const memory = new WebAssembly.Memory({
  initial: 256,  // 16 MB
  maximum: 512   // 32 MB limit
});

// Provide minimal imports
const importObject = {
  env: {
    memory,
    // Only expose necessary functions
    log: console.log
  }
};
```

---

## 🧪 Testing Across Environments

### **1. Local Testing**

```json
// package.json
{
  "scripts": {
    "dev": "vite --host",
    "dev:headers": "vite --host --cors",
    "test:wasm": "node --experimental-wasm-modules test.js",
    "serve": "http-server dist -p 8080 --cors"
  }
}
```

---

### **2. Browser Testing**

```javascript
// Automated testing with Playwright
import { test, expect } from '@playwright/test';

test('WebAssembly module loads', async ({ page }) => {
  await page.goto('http://localhost:3000');
  
  // Check if Wasm is supported
  const wasmSupport = await page.evaluate(() => {
    return typeof WebAssembly !== 'undefined';
  });
  expect(wasmSupport).toBe(true);
  
  // Test Wasm function
  const result = await page.evaluate(async () => {
    const module = await import('./module.js');
    await module.default();
    return module.calculate(5, 10);
  });
  expect(result).toBe(15);
});
```

---

### **3. Cross-Browser Testing**

```javascript
// Jest configuration
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/setup-tests.js'],
  transform: {
    '^.+\\.wasm$': '<rootDir>/wasm-transformer.js'
  }
};
```

---

## 🌍 Node.js Server Compatibility

### **Native WebAssembly Support**

Node.js has built-in WebAssembly support (v8.0+):

```javascript
// Load Wasm in Node.js
const fs = require('fs');
const wasmBuffer = fs.readFileSync('./module.wasm');

WebAssembly.instantiate(wasmBuffer, {
  env: {
    // Import functions
  }
}).then(({ instance }) => {
  console.log(instance.exports.calculate(5, 10));
});
```

---

### **WASI (WebAssembly System Interface)**

```javascript
// Node.js 20+ with WASI support
import { readFile } from 'node:fs/promises';
import { WASI } from 'wasi';
import { argv, env } from 'node:process';

const wasi = new WASI({
  version: 'preview1',
  args: argv,
  env,
  preopens: {
    '/sandbox': '/tmp'
  }
});

const wasm = await WebAssembly.compile(
  await readFile('./module.wasm')
);

const instance = await WebAssembly.instantiate(wasm, {
  wasi_snapshot_preview1: wasi.wasiImport
});

wasi.start(instance);
```

---

## 📊 Performance Monitoring

### **1. Load Time Tracking**

```javascript
// Measure Wasm load and instantiation time
async function loadWasmWithMetrics(url) {
  const metrics = {};
  
  // Fetch time
  const fetchStart = performance.now();
  const response = await fetch(url);
  metrics.fetchTime = performance.now() - fetchStart;
  
  // Download time
  const downloadStart = performance.now();
  const buffer = await response.arrayBuffer();
  metrics.downloadTime = performance.now() - downloadStart;
  metrics.size = buffer.byteLength;
  
  // Compilation time
  const compileStart = performance.now();
  const module = await WebAssembly.compile(buffer);
  metrics.compileTime = performance.now() - compileStart;
  
  // Instantiation time
  const instantiateStart = performance.now();
  const instance = await WebAssembly.instantiate(module, {});
  metrics.instantiateTime = performance.now() - instantiateStart;
  
  metrics.totalTime = performance.now() - fetchStart;
  
  console.log('Wasm Load Metrics:', metrics);
  return instance;
}
```

---

### **2. Runtime Performance**

```javascript
// Benchmark Wasm function
function benchmarkWasm(fn, iterations = 1000) {
  const times = [];
  
  for (let i = 0; i < iterations; i++) {
    const start = performance.now();
    fn();
    times.push(performance.now() - start);
  }
  
  return {
    mean: times.reduce((a, b) => a + b) / times.length,
    min: Math.min(...times),
    max: Math.max(...times),
    median: times.sort()[Math.floor(times.length / 2)]
  };
}
```

---

## 🚨 Common Deployment Issues & Solutions

### **Issue 1: MIME Type Error**
```
Failed to load module: expected 'application/wasm'
```

**Solution:**
```nginx
# Nginx
types {
    application/wasm wasm;
}

# Or in location block
location ~* \.wasm$ {
    types { application/wasm wasm; }
}
```

---

### **Issue 2: CORS Errors**
```
Cross-Origin Request Blocked
```

**Solution:**
```javascript
// Express
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET');
  next();
});
```

---

### **Issue 3: SharedArrayBuffer Not Available**
```
SharedArrayBuffer is not defined
```

**Solution:** Add required headers:
```
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
```

---

### **Issue 4: Memory Growth Issues**
```
Out of memory
```

**Solution:**
```javascript
const memory = new WebAssembly.Memory({
  initial: 256,
  maximum: 16384,  // Increase max pages
  shared: true     // For threading
});
```

---

## ✅ Deployment Checklist

- [ ] Configure correct MIME type for `.wasm` files
- [ ] Add COOP and COEP headers for threading support
- [ ] Enable compression (Gzip/Brotli) for Wasm files
- [ ] Set appropriate cache headers
- [ ] Test in all target browsers
- [ ] Implement feature detection and fallbacks
- [ ] Monitor load times and bundle sizes
- [ ] Configure CSP headers properly
- [ ] Test with and without threading
- [ ] Verify HTTPS in production
- [ ] Set up error tracking for Wasm load failures
- [ ] Document browser support requirements